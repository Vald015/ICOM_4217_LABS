/*
 * ICOM 4217 (EMBEDDED SYSTEM DESIGN)
 * Authors: Carlos A. Rodriguez & Osvaldo A. Ramirez
 * LAB4 PART1: Timer by Polling
 * Instructions:
 * Produce an audible sound using delays generated by polling th timer's Top count flag.
 */

/* Header Files */
#include <stdint.h>
#include <stdbool.h>
#include "inc/tm4c123gh6pm.h"
#include "inc/hw_memmap.h"
#include "inc/hw_types.h"
#include "driverlib/sysctl.h"
#include "driverlib/interrupt.h"
#include "driverlib/gpio.h"
#include "driverlib/timer.h"

/* Function Declaration */
void PB1_IntHandler (void);

/* Variable Declaration */
uint32_t period;									//Period of the timer
int interruptFlag = 0;								//Interrupt flag for the push button
uint16_t frequencies[] = {500,1000,1500,2000,3000};	//Different frequencies for the buzzer
int index=0;										//index pointer to the frequencies array

/* Main Code */
int main(void){

	SysCtlClockSet(SYSCTL_SYSDIV_5|SYSCTL_USE_PLL|SYSCTL_XTAL_16MHZ|SYSCTL_OSC_MAIN);		//Set system clock to 40MHz

	/* System Peripherals enable */
	SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOA);			//Enable GPIO PORT A
	SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOC);			//Enable GPIO PORT C
	SysCtlPeripheralEnable(SYSCTL_PERIPH_TIMER0);			//Enable TIMER 0

	/* Peripheral Configuration */
	TimerConfigure(TIMER0_BASE,TIMER_CFG_PERIODIC);							//Configure timer to count down
	GPIOPinTypeGPIOOutput(GPIO_PORTC_BASE,GPIO_PIN_4);						//Set Port C PIN 4 as output
	GPIOPinTypeGPIOInput(GPIO_PORTA_BASE, GPIO_PIN_5); 						//Set Port A PIN 5 as input
	GPIOPadConfigSet(GPIO_PORTA_BASE, GPIO_PIN_5, GPIO_STRENGTH_4MA, GPIO_PIN_TYPE_STD_WPD); //Set the PIN 5 of PORT A current strength Pin Type to Pull down
	GPIOIntRegister(GPIO_PORTA_BASE, PB1_IntHandler); 										//Registers an interrupt handler for a GPIO port. Ensures that the interrupt handler specified is called.
	GPIOIntTypeSet(GPIO_PORTA_BASE, GPIO_PIN_5, GPIO_RISING_EDGE); 							//Sets the interrupt type for the specified pin(s). GPIO_RISING_EDGEsets detection to edge and trigger to rising(low to high transition)
	period = ((SysCtlClockGet()/frequencies[index])/2)-1;									//Calculate the period of the timer at 50% duty cycle
	TimerLoadSet(TIMER0_BASE,TIMER_A,period);												//Load the timer with the calculated period

	/* Enable */
	TimerEnable(TIMER0_BASE,TIMER_A);									//Enable Timer
	GPIOIntEnable(GPIO_PORTA_BASE, GPIO_PIN_5);     					// Enable interrupt for PA4


	while (1){
		uint32_t test = TimerValueGet(TIMER0_BASE,TIMER_A);				//Get current timer
		if(test <= 30){													//test if the timer's current value is lower than 30
			if(GPIOPinRead(GPIO_PORTC_BASE,GPIO_PIN_4)){				//check pin status
				GPIOPinWrite(GPIO_PORTC_BASE, GPIO_PIN_4,0);			//If the buzzer is on, turn it off
			}else{
				GPIOPinWrite(GPIO_PORTC_BASE,GPIO_PIN_4,16);			//If the buzzer is off, turn it on
			}
		}

		if(interruptFlag == 1){										//Check interrupt flag
			index++;												//Increase index
			if(index > 4){											//If index is greater than 4 set it to zero to keep it whithin array size
				index = 0;											//Set index to zero
			}
			period = (SysCtlClockGet()/frequencies[index]/2)-1;		//Calculate the new period for the desired frequency
			TimerLoadSet(TIMER0_BASE,TIMER_A, period);				//Load the timer with the calculated period
			interruptFlag = 0;										//Set interrupt flag equal to zero
		}

	}
}

/* Button Interrupt handler */
void PB1_IntHandler (void)
{
	SysCtlDelay(400000); 								//Running at 30ms
	interruptFlag = 1;									//Set interrupt flag equal to 1
	GPIOIntClear (GPIO_PORTA_BASE, GPIO_PIN_5);			// Clear
}



